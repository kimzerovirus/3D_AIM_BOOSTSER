## 버블 정렬
> 데이터의 인접요소끼리 비교하고 스왑연산 <br/>
> 앞,뒤 비교 <br/>
> O(n^2)
1. 비교 연산이 필요한 루프 범위 설정
2. 인접 데이터 끼리 비교
3. 비교 조건에 따라 스왑
4. 루프가 끝날 때까지 2~3 반복
5. 정렬 영역 재설정, 이전의 작업을 통해 정렬된 영역은 범위에서 제외
6. 비교 대상이 없을 때까지 1~5 반복
```
A : 정렬할 배열

for(i: 0 ~ A.length) {
    for(j: 0 ~ A.length - i) {
        정렬 조건 -> 스왑연산
    }
}
```
## 선택 정렬
> 대상에서 가장 크거나 작은 요소 찾아서 가장 앞의 데이터와 비교하고 스왑하는 연산
> 최댓값 또는 최솟값 요소를 찾아서 맨 앞과 비교
1. 남은 정렬 부분에서 최솟값 or 최댓값 찾기
2. 남은 정렬 부분의 맨 앞 데이터와 선택된 요소 비교
3. 맨 앞 데이터 위치를 변경하고 index++, 남은 정렬 범위 축소
4. 전체 데이터 크기만큼 index 가 커질 때 까지 반복

## 삽입 정렬
> 이미 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬
> O(n^2)
1. 현재 index 에 있는 데이터 선택
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색 (이진 탐색 등 탐색 알고리즘을 사용해서 시간 단축 가능)
3. 삽입 위치부터 index 위치까지 shift 연산 수행
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++
5. index 가 전체 데이터 크기 만큼 커질 때 까지 반복

## 퀵 정렬
> pivot을 기준으로 pivot보다 작은 요소들은 모두 pivot의 왼쪽으로 옮기고 pivot보다 큰 요소들은 모두 pivot의 오른쪽으로 옮긴다.<br/>
> 기준점을 기준으로 옮기는 정렬

## 병합 정렬
> 이미 정렬된 집합들을 하나로 병합하는 정렬

## 기수 정렬
> 데이터의 자릿수를 바탕으로 비교해 정렬
